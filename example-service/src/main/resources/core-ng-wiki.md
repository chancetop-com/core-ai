# CoreNg Guide
## 1.1 - Overview
Core-ng services consist of two primary high-level components:
1. An application class that extends `core.framework.module.App`
2. One or more module classes that extend `core.framework.module.Module`

The `App` class itself extends the `Module` class, adding some additional functionality required for starting the app and configuring the `ModuleContext`. Applications are bootstrapped via a Main.java class that instantiates the app class and calls its `start()` method.

The `ModuleContext` (`core.framework.internal.module.ModuleContext`) is the container class that manages a number of core internal components for an application, including the HTTPServer class (powered by the Undertow networking library), a `ServiceRegistry` for user-implemented service classes, a `BeanFactory` for injectable singleton classes, various config classes, server startup and shutdown hooks, and a few other pieces. The members of the `ModuleContext` will be discussed in detail later on.

All of the modules that comprise an application share the same module context. When an application is started, the app class loads each module by providing the module a reference to the application-level module context and calling the given module's initialize() method for module-specific setup.

### Modules
The `core.framework.module.Module` class, as the name implies, provides methods for managing and configuring the various features supported by the Core-ng framework in a modularized fashion. As needed, it attaches these configurations and functionalities to the applicaton module context. The full list of feature configurations, found in `core.framework.module.*`  are listed below:

- LogConfig
- HTTPConfig
- WebsocketConfig
- SiteConfig
- CacheConfig
- SchedulerConfig
- ExecutorConfig
- APIConfig
- DBConfig
- RedisConfig
- KafkaConfig

## 1.2 Getting Started
This section will take you through setting up and running a basic Core-ng application on your local machine.

### Prerequisites (OSX)
#### Java
As of writing, Wonder uses the Eclipse Temurin OpenJDK for Java 21. We recommend installing SDKMAN! for managing Java versions locally. With SDKMAN!, installing a new version of Java can be done in a single command:
```
> sdk install java 21.0.2-tem 
```
#### IntelliJ (Optional)
It is also highly recommended to install the IntelliJ Idea IDE. While it is possible and perfectly fine to use a different IDE to set up a Core-ng project, IntelliJ provides a lot of convenient project setup and management features that will be utilized in this guide. For manual setup, you will likely want to install Gradle and take a look at the `gradle init` command.

### Project Setup
To begin, create a new project in IntelliJ using Gradle as the build system, Java as the language, and Kotlin as the Gradle DSL. Be sure to set the `Project JDK` to Java 21- you can add a JDK to IntelliJ with the `Add JDK...` option from the JDK dropdown in the project creation wizard. If you installed Eclipse Temurin 21 via SDKMAN!, the home path should be:
```
/Users/<user>/.sdkman/candidates/java/21.0.2-tem
```
Name your new project, finish the setup, and IntelliJ will create a Gradle project with a standard Java directory structure to work with. Quickly verify that the proper JDK (Open JDK 21) is set as the project default and the Gradle JVM by checking `File -> Project Structure -> Project SDK` as well as `Preferences -> Build, Execution, Deployment -> Build Tools -> Gradle -> Gradle JVM`. You will encounter errors running your project if these fields are not correctly configured.

#### (Java) Module Setup
The Core-ng demo project includes useful setup files that we will take advantage of to get our project going quickly. Open a terminal and clone the demo repository to a separate directory:
```
> git clone https://github.com/neowu/core-ng-demo-project.git
```
Now, copy the `buildSrc` directory from the Core-ng demo project and paste it into your new project. This adds a number of gradle tasks that will be useful for our project (TODO: more details on these).

Delete the `src` directory that was generated by IntelliJ, right-click the root directory and use `New -> Module` to create a module called "demo-service", and delete the new module's build.gradle.kts file once it's created. Finally, update the root `build.gradle.kts` to the following:
```
plugins {
    java
}
apply(plugin = "project")
subprojects {
    group = "core.demo"
    version = "1.0.0"
    repositories {
        maven {
            url = uri("https://neowu.github.io/maven-repo/")
            content {
                includeGroupByRegex("core\\.framework.*")
            }
        }
        maven {
            url = uri("https://maven.codelibs.org/")
            content {
                includeGroup("org.codelibs.elasticsearch.module")
            }
        }
    }
    if (childProjects.isEmpty()) {
        sourceSets {
            create("dev") {
                java.srcDir("src/dev/java")
                compileClasspath += sourceSets["main"].runtimeClasspath
                runtimeClasspath += sourceSets["main"].runtimeClasspath
            }
        }
    }
}
val coreNGVersion = "9.0.9"
configure(listOf(project(":demo-service"))) {
    apply(plugin = "app")
    dependencies {
        implementation("core.framework:core-ng:${coreNGVersion}")
        testImplementation("core.framework:core-ng-test:${coreNGVersion}")
    }
}
```
#### Launching the Application
As mentioned in the Overview, Core-ng applications generally comprise two main component types: an App class and one or more Module classes. However, it is possible to start a Core-ng application with only an App class.

In `demo-service/src/main/java/app`, create the following `DemoApp.class` file:
```
package app;
import core.framework.module.App;
public class DemoApp extends App {
    @Override
    protected void initialize() {
        http().listenHTTP("8080");
    }
}
```
This sets up a basic web app listening on https://localhost:8080. To launch the app, create a `Main.java` class file in `demo-service/src/main/java` that imports and starts your app:
```
import app.DemoApp;
public class Main {
    public static void main(String[] args) {
        new DemoApp().start();
    }
}
```
That's it! From the Gradle menu in IntelliJ (right side bar), use the task under `demo-service -> Tasks -> application -> run` to run your app. Be sure to refresh Gradle if you don't see these options. Visit http://localhost:8080/_sys/property to see a dump of the system properties. Core-ng provides a number of `_sys` endpoints out of the box that provide diagnostic data for your application (// TODO see more here). In the next section, we'll add a basic REST endpoint to our app.

## 1.3 - A Basic Web Service Module
This section will walk through creating a basic web service with the Core-ng framework. It assumes you've already completed the Getting Started section.

### Defining the Service Interface
All web services in Core-ng should be defined via a service interface. The framework provides annotations (see `core.framework.api.web.service.*`) for defining routes (`@Path`), route parameters (`@PathParam`), query parameters (@`QueryParam`), response statuses (`@ResponseStatus`), and standard HTTP verbs:
- @GET
- @POST
- @PUT
- @PATCH
- @DELETE

In addition to defining the service REST interface, it is expected that all request and response objects be defined as classes.

To get started, right click the root directory and use `New -> Module` to create a new `demo-service-interface` module in our project. Delete the new module's auto-generated build.gradle file and add the interface as a project dependency for our `demo-service` in the root `build.gradle` (as well as the interface module's Core-ng dependency):
```
plugins {
    java
}
apply(plugin = "project")
subprojects {
    group = "core.demo"
    version = "1.0.0"
    repositories {
        maven {
            url = uri("https://neowu.github.io/maven-repo/")
            content {
                includeGroupByRegex("core\\.framework.*")
            }
        }
        maven {
            url = uri("https://maven.codelibs.org/")
            content {
                includeGroup("org.codelibs.elasticsearch.module")
            }
        }
    }
    if (childProjects.isEmpty()) {
        sourceSets {
            create("dev") {
                java.srcDir("src/dev/java")
                compileClasspath += sourceSets["main"].runtimeClasspath
                runtimeClasspath += sourceSets["main"].runtimeClasspath
            }
        }
    }
}
val coreNGVersion = "9.0.9"
configure(listOf(project(":demo-service"))) {
    apply(plugin = "app")
    dependencies {
        implementation(project(":demo-service-interface"))
        implementation("core.framework:core-ng:${coreNGVersion}")
        testImplementation("core.framework:core-ng-test:${coreNGVersion}")
    }
}
configure(listOf(project(":demo-service-interface"))) {
    dependencies {
        implementation("core.framework:core-ng-api:${coreNGVersion}")
    }
}
```
Next, in `demo-service-interface/src/main/java`, create a new package `app.demo.api` and a new directory `customer` in that package. For now, we'll create two simple customer endpoints that mock creating and retreiving a customer resource. In the new `customer` directory, let's define a  `CreateCustomerRequest.class` request object:

```
package app.demo.api.customer;
import core.framework.api.json.Property;
import core.framework.api.validate.NotBlank;
import core.framework.api.validate.NotNull;
public class CreateCustomerRequest {
    @NotNull
    @NotBlank
    @Property(name = "email")
    public String email;
    @NotNull
    @NotBlank
    @Property(name = "first_name")
    public String firstName;
    @NotBlank
    @Property(name = "last_name")
    public String lastName;
}
```
Core-ng provides yet more annotations here to define JSON properties and basic JSON validation (TODO: link to docs for more). We'll also need a `CustomerView.class` response object:

```
package app.demo.api.customer;
import core.framework.api.json.Property;
import core.framework.api.validate.NotBlank;
import core.framework.api.validate.NotNull;
import java.time.LocalDateTime;
public class CustomerView {
    @NotNull
    @Property(name = "id")
    public Long id;
    @NotNull
    @NotBlank
    @Property(name = "email")
    public String email;
    @NotNull
    @NotBlank
    @Property(name = "first_name")
    public String firstName;
    @NotBlank
    @Property(name = "last_name")
    public String lastName;
    @NotNull
    @Property(name = "updated_time")
    public LocalDateTime updatedTime;
}
```
Now, in `demo-service-interface/src/main/java/app/demo/api`, we can define our REST interface with POST and GET endpoints:

```
package app.demo.api;
import app.demo.api.customer.CreateCustomerRequest;
import app.demo.api.customer.CustomerView;
import core.framework.api.http.HTTPStatus;
import core.framework.api.web.service.GET;
import core.framework.api.web.service.POST;
import core.framework.api.web.service.Path;
import core.framework.api.web.service.PathParam;
import core.framework.api.web.service.ResponseStatus;
public interface CustomerWebService {
    @POST
    @Path("/customer")
    @ResponseStatus(HTTPStatus.CREATED)
    CustomerView create(CreateCustomerRequest request);
    @GET
    @Path("/customer/:id")
    CustomerView get(@PathParam("id") Long id);
}
```
This interface defines two different routes:
- A POST route at `/customer` that will return a HTTP 201 status if the resource is successfully created
- A GET route at `/customer/:id`, where `:id` is a path parameter that will automatically be parsed from the route and cast to a `Long` when the request is processed

### Implementing the Service Interface
Per Core-ng conventions, for each resource with a defined interface in `${some-name}-service-interface`, the corresponding `${some-name}-service` module should impement that service interface. In general, this is separated into three sub-packages with different responsibilities:

- the `domain` package defines data access objects (DAOs) for the backing repository (MySQL, Mongo, etc)
- the `service` package contains classes that implement the business logic for out services, injecting Respository (more on these later) classes for accessing our domain objects as needed
- the `web` package contains the implementations of web service interfaces, injecting and calling the service classes as needed

So for our demo application, in `demo-service/src/main/java` we would have the following packages:
- app.demo.customer.domain
- app.demo.customer.service
- app.demo.customer.web

Because our mock service is not backed by a data store yet (we will discuss repositories in the next section), let's just implement a simple `CustomerService.class` in `app.demo.customer.service`:

```
package app.demo.customer.service;
import app.demo.api.customer.CreateCustomerRequest;
import app.demo.api.customer.CustomerView;
import java.time.LocalDateTime;
public class CustomerService {
   public CustomerView create(CreateCustomerRequest request) {
       return mockCustomer(1L);
   }
   public CustomerView get(Long id) {
       return mockCustomer(id);
   }
   private CustomerView mockCustomer(Long id) {
       CustomerView customer = new CustomerView();
       customer.id = id;
       customer.firstName = "Charlie";
       customer.lastName = "Fox";
       customer.email = "charlie@remarkablefoods.com";
       customer.updatedTime = LocalDateTime.now();
       return customer;
   }
}
```
Next, let's implement the the interface we defined earlier with a new `CustomerWebServiceImpl` in `app.demo.customer.web`:

```
package app.demo.customer.web;
import app.demo.api.CustomerWebService;
import app.demo.api.customer.CreateCustomerRequest;
import app.demo.api.customer.CustomerView;
import app.demo.customer.service.CustomerService;
import core.framework.inject.Inject;
public class CustomerWebServiceImpl implements CustomerWebService {
    @Inject
    CustomerService customerService;
    @Override
    public CustomerView create(CreateCustomerRequest request) {
        return  customerService.create(request);
    }
    @Override
    public CustomerView get(Long id) {
        return customerService.get(id);
    }
}
```
Our service interface and implementations are in place! Notice the `@Inject` annotation- this annotation prompts the application context to provide an instance of our `CustomerService.class` to the `CustomerWebServiceImpl.class` via dependency injection. For this to succeed, we must bind our `CustomerService.class` to the module context, which we will complete next.

### Creating and Loading a Web Module
As a final step, we need to create a customer module, register our web interface with the module, and load the module in our application. Define the `CustomerModule.class` in `demo-service/src/main/java/app`:

```
package app;
import app.demo.api.CustomerWebService;
import app.demo.customer.service.CustomerService;
import app.demo.customer.web.CustomerWebServiceImpl;
import core.framework.module.Module;
public class CustomerModule extends Module {
    @Override
    protected void initialize() {
        bind(CustomerService.class);
        api().service(CustomerWebService.class, bind(CustomerWebServiceImpl.class));
    }
}
```
A few things are happening here:
- we bind our `CustomerService.class` service and the CustomerWebServiceImpl.class implementation to the application module context so they can be injected and used as needed.
- we use the APIConfig feature to define a service on our module context, which sets up handlers on the internal Core-ng HTTPServer in the context and maps our route definitions in the interface to their proper service method implementations

During this process, Core-ng also verifies that all route definitions are valid (for example, that `@PathParams` expect supported types) and have corresponding service implementations, throwing Errors as needed.

At last, let's load our new `CustomerModule.class` in our application `DemoApp.class`:

```
package app;
import core.framework.module.App;
public class DemoApp extends App {
    @Override
    protected void initialize() {
        http().listenHTTP("8080");
        load(new CustomerModule());
    }
}
```
Our basic web service module is complete!

### Manually Test the Web Service Module
Run the app via the gradle menu by launching the task `demo-service -> Tasks -> application -> run`. A curl request to our webs service should then return our mock customer object with the id provided in the route:
```
>  curl localhost:8080/customer/1 | json_pp
```
```
{
   "id": 1,
   "email": "charlie@remarkablefoods.com",
   "first_name": "Charlie",
   "last_name": "Fox",
   "updated_time": "2020-04-14T12:56:32.661839"
}
```
If you want, try testing our POST endpoint as well. In the next section, we'll take a look at using Core-ng with a database!
## 1.4 - Using Core-ng Repositories
This section will walk through using Core-ng repositories to access a database in your application. It continues developing the app started in sections 1.2 and 1.3.

### Prerequisites
In order to take advantage of the Core-ng repository utilities, we'll first need to setup a backing database service. Docker Compose makes it easy to spin up various services for local development and can be installed via the Docker website here.

Next, download the local_environment project from git, which provides a baseline `docker-compose.yaml` that sets up many of the common backing services used by Core-ng for local development:

```
> git clone https://github.com/food-truck/local-environment.git
```
Run just the MySQL service by entering the root local_env directory of the cloned repo in a terminal and running:
```
> docker-compose up mysql
```
You may also want to install software such as DBeaver or MySQL Workbench so that it is easier to modify the MySQL instance and add databases when needed. The root password for your local MySQL instance can be found in the `local_env/docker-compose.yaml` file under the `mysql` service definition (username: root, password: root).

### Project Setup
To setup Core-ng repositories for MySQL in your project, first add the MySQL driver to your project via the `build.gradle.kts` project as a `runtimeOnly` dependency:

```
plugins {
    java
}
apply(plugin = "project")
subprojects {
    group = "core.demo"
    version = "1.0.0"
    repositories {
        maven {
            url = uri("https://neowu.github.io/maven-repo/")
            content {
                includeGroupByRegex("core\\.framework.*")
            }
        }
        maven {
            url = uri("https://maven.codelibs.org/")
            content {
                includeGroup("org.codelibs.elasticsearch.module")
            }
        }
    }
    if (childProjects.isEmpty()) {
        sourceSets {
            create("dev") {
                java.srcDir("src/dev/java")
                compileClasspath += sourceSets["main"].runtimeClasspath
                runtimeClasspath += sourceSets["main"].runtimeClasspath
            }
        }
    }
}
val coreNGVersion = "9.0.9"
configure(listOf(project(":demo-service"))) {
    apply(plugin = "app")
    dependencies {
        implementation(project(":demo-service-interface"))
        implementation("core.framework:core-ng:${coreNGVersion}")
        runtimeOnly("core.framework.mysql:mysql-connector-j:8.4.0-r2")
        testImplementation("core.framework:core-ng-test:${coreNGVersion}")
    }
}
configure(listOf(project(":demo-service-interface"))) {
    dependencies {
        implementation("core.framework:core-ng-api:${coreNGVersion}")
    }
}
```
### The System Module
As a final setup step, we must provide our application with the proper URL and credentials to access the local MySQL instance running via Docker. A special Core-ng module, the SystemModule (`core.framework.module.SystemModule`), provides a number of methods for configuring backing services. To use the SystemsModule, let's define a system properties file in `/demo-service/src/main/resources/sys.properties`:

```
sys.jdbc.password=root
sys.jdbc.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=utf-8
sys.jdbc.user=root
```

This file defines the URL and credentials for our local MySQL instance to be used by the application.

> Note: You will need to connect to the MySQL instance using MySQL Workbench or a similar tool and create a demo database or the connection to jdbc:mysql://127.0.0.1:3306/demo defined above will error. Use utf8mb4 as the character encoding when creating the new database. Addtionally, you should add a new customers table to the database with the correct columns present:


```
CREATE TABLE `customers` (
  `id` int NOT NULL AUTO_INCREMENT,
  `email` varchar(50) NOT NULL,
  `first_name` varchar(50) NOT NULL,
  `last_name` varchar(50) DEFAULT NULL,
  `updated_time` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `email` (`email`)
)
```
Finally, in our DemoApp.class application class, create and load a new SystemModule, pointing it to our new sys.properties file:


```
package app;
import core.framework.module.App;
import core.framework.module.SystemModule;
public class DemoApp extends App {
    @Override
    protected void initialize() {
        http().listenHTTP("8080");
        load(new SystemModule("sys.properties"));
        load(new CustomerModule());
    }
}
```
Our local MySQL instance should now be properly configured.

### Defining a Domain Object
Domain objects are our data access objects (DAOs) that map directly to a record in a database table. Let's define a Customer.class domain object in a new `demo-service/src/main/java/app/demo/customer/domain` package:


```
package app.demo.customer.domain;
import core.framework.api.validate.NotBlank;
import core.framework.api.validate.NotNull;
import core.framework.db.Column;
import core.framework.db.PrimaryKey;
import core.framework.db.Table;
import java.time.LocalDateTime;
@Table(name = "customers")
public class Customer {
    @PrimaryKey(autoIncrement = true)
    @Column(name = "id")
    public Long id;
    @NotNull
    @NotBlank
    @Column(name = "email")
    public String email;
    @NotNull
    @NotBlank
    @Column(name = "first_name")
    public String firstName;
    @NotBlank
    @Column(name = "last_name")
    public String lastName;
    @NotNull
    @Column(name = "updated_time")
    public LocalDateTime updatedTime;
}
```
Notice a few things here:

- The @Table annotation marks this class as a SQL domain object, with the name parameter corresponding to the table name in the database. Per Core-ng conventions, the table name is plural (customers), while the class name is singular (Customer), as an instance of this object most commonly represents a single customer record in the customers table.
- Table columns are marked via the the @Column annotation. Per Core-ng conventions, column names are lowercase underscore-separated labels, while the corresponding java member variable is the identical name with camelCase labeling (ex last_name and lastName).
- Every domain object must have a @PrimaryKey column, which can be configured to use an autoIncrement key generated by the database or an application-generated UUID. Per conventions, the primary key column is always called id.
- The classes in core.framework.api.validate.* provide a number of annotations for validating columns in a domain object, including @NotBlank, @NotNull, @Min, @Max, and others. See the validate documentation (//TODO) for more details.

### Using the Domain Object
It's finally time to use our domain object! Let's replace the mock service implementations from section 1.3 in CustomerService.class with real database calls using the utilities provided by Core-ng:


```
package app.demo.customer.service;
import app.demo.api.customer.CreateCustomerRequest;
import app.demo.api.customer.CustomerView;
import app.demo.customer.domain.Customer;
import core.framework.db.Repository;
import core.framework.inject.Inject;
import core.framework.util.Strings;
import core.framework.web.exception.ConflictException;
import core.framework.web.exception.NotFoundException;
import java.time.LocalDateTime;
import java.util.Optional;
public class CustomerService {
    @Inject
    Repository<Customer> customerRepository;
    public CustomerView create(CreateCustomerRequest request) {
        Optional<Customer> existingCustomer = customerRepository.selectOne("email = ?", request.email);
        if (existingCustomer.isPresent()) {
            throw new ConflictException(Strings.format("customer already exists, email={}", request.email));
        }
        Customer customer = new Customer();
        customer.email = request.email;
        customer.firstName = request.firstName;
        customer.lastName = request.lastName;
        customer.updatedTime = LocalDateTime.now();
        customer.id = customerRepository.insert(customer).orElseThrow();
        return view(customer);
    }
    public CustomerView get(Long id) {
        Customer customer = customerRepository.get(id).orElseThrow(() -> new NotFoundException(Strings.format("customer not found, id={}", id)));
        return view(customer);
    }
    private CustomerView view(Customer customer) {
        CustomerView result = new CustomerView();
        result.id = customer.id;
        result.email = customer.email;
        result.firstName = customer.firstName;
        result.lastName = customer.lastName;
        result.updatedTime = customer.updatedTime;
        return result;
    }
}
```
Once again, we use the @Inject annotation, this time to add a repository class that wraps our Customer.class domain object, allowing us to take advantage of a number of convienence methods for making simple CRUD queries to the "customers" table that backs our domain class. See the Querying Repositories (//TODO) section to read more about querying with the Core-ng Repository and other ways to query databases with Core-ng.

Also, notice the use of Strings.format() to format out error messages. Core-ng's core.framework.util.* provides a number of utilitiy classes that you can read about here.

### Wiring Up the Repository Class
As a final step, we'll use the DBConfig on out CustomerModule.class module to register our domain object:


```
package app;
import app.demo.api.CustomerWebService;
import app.demo.customer.domain.Customer;
import app.demo.customer.service.CustomerService;
import app.demo.customer.web.CustomerWebServiceImpl;
import core.framework.module.Module;
public class CustomerModule extends Module {
    @Override
    protected void initialize() {
        db().repository(Customer.class);
        bind(CustomerService.class);
        api().service(CustomerWebService.class, bind(CustomerWebServiceImpl.class));
    }
}
```
This binds a Repository<Customer> repository to our application module context, which we injected in the CustomerService.class service to query our database.

### Manually Testing the Repository
Run the app via the gradle menu by launching the task demo-service -> Tasks -> application -> run. Be sure your local MySQL instance is running by entering the local-env repo in a terminal and using:


```
> docker-compose start mysql
```
> Note: By using docker-compose start here instead of docker-compose up, you prevent docker from re-creating your mysql container, which may wipe the contents of your database between starts.

Now test creating a customer resource via our POST endpoint:


```
> curl --header "Content-Type: application/json" \
  --request POST \
  --data '{"first_name": "Charlie", "last_name": "Fox", "email": "charlie@remarkablefoods.com"}' \
  http://localhost:8080/customer | json_pp
```
```
{
  "id" : 1,
  "last_name" : "Fox",
  "first_name" : "Charlie",
  "updated_time" : "2020-04-20T12:47:56.53133",
  "email" : "charlie@remarkablefoods.com",
}
```
Finally, GET the resource you just created by id:


```
>  curl localhost:8080/customer/1 | json_pp
```
```
{
   "id" : 1,
   "first_name" : "Charlie",
   "email" : "charlie@remarkablefoods.com",
   "last_name" : "Fox",
   "updated_time" : "2020-04-20T12:47:57.000"
}
```
Our app is now backed by a live database!
## 1.5 - Core-ng Async

This section will walk through Core-ng's async APIs including:
- the Executor
- the Scheduler
- Kafka support

It assumes you have completed the previous Getting Started sections 1.2-1.4

### The Executor
For long-running tasks initiated by requests that threaten to cause HTTP timeouts, Core-ng provides the Executor API so that these otherwise blocking tasks may be run asychronously, allowing the request to return immediately. Since Core-ng version 9, executors have been powered by Java virtual threads. Core-ng's executor implementation in core.framework.internal.async.ExecutorImpl uses java.util.concurrent.ExecutorService and java.util.concurrent.ScheduledExecutorService under the hood, wrapping these classes with additional logging and functionality.

#### Injecting and Using the Executor
To use the executor, it can be injected into a service and fed Tasks as Java lambda functions via the submit() method:


```
package app.demo.customer.service;
import app.demo.api.customer.CreateCustomerRequest;
import app.demo.api.customer.CustomerView;
import app.demo.customer.domain.Customer;
import core.framework.async.Executor;
import core.framework.db.Repository;
import core.framework.inject.Inject;
import core.framework.util.Strings;
import core.framework.web.exception.ConflictException;
import core.framework.web.exception.NotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Optional;
public class CustomerService {
    private final Logger logger = LoggerFactory.getLogger(CustomerService.class);
    @Inject
    Repository<Customer> customerRepository;
    @Inject
    Executor executor;
    public CustomerView create(CreateCustomerRequest request) {
        Optional<Customer> existingCustomer = customerRepository.selectOne("email = ?", request.email);
        if (existingCustomer.isPresent()) {
            throw new ConflictException(Strings.format("customer already exists, email={}", request.email));
        }
        Customer customer = new Customer();
        customer.email = request.email;
        customer.firstName = request.firstName;
        customer.lastName = request.lastName;
        customer.updatedTime = LocalDateTime.now();
        customer.id = customerRepository.insert(customer).orElseThrow();
        executor.submit("normal-task", () -> {
            logger.info("Customer created!");
        });
        executor.submit("delayed-task", () -> {
            logger.info("Customer created about 10s ago!");
        }, Duration.ofSeconds(10));
        return view(customer);
    }
    public CustomerView get(Long id) {
        Customer customer = customerRepository.get(id).orElseThrow(() -> new NotFoundException(Strings.format("customer not found, id={}", id)));
        return view(customer);
    }
    private CustomerView view(Customer customer) {
        CustomerView result = new CustomerView();
        result.id = customer.id;
        result.email = customer.email;
        result.firstName = customer.firstName;
        result.lastName = customer.lastName;
        result.updatedTime = customer.updatedTime;
        return result;
    }
}
```
The Executor submit() method takes a task name for logging as the first argument, followed by the Task itself. An optional delay duration may be added as well, shown above in the "delayed-task". For this example, the tasks simply log simple messages, though in practice these would do more work. The core.framework.async.Task functional interface itself is very similar java.lang.Runnable except it allows for exceptions to be thrown:


```
package core.framework.async;
/**
 * @author neo
 */
@FunctionalInterface
public interface Task {
    void execute() throws Exception;    // not using Runnable to allow throw exception
}
```
Core-ng's executor implementation in core.framework.internal.async.ExecutorImpl uses java.util.concurrent.ExecutorService and java.util.concurrent.ScheduledExecutorService under the hood, wrapping these classes with additional logging and functionality.

#### Testing Our Async Tasks
The async tasks we created were added to the CustomerService.create() method. To test them out, run the app and create a new customer via our POST /customer endpoint. See section 1.4 if you need a reminder how to do this with curl.

After a customer is created, we should see our first async task execute and log a message:


```
2020-04-28T16:19:47.836727Z [local] [executor-0] INFO a.d.c.service.CustomerService - Customer created!
Followed by our delayed task 10 seconds later:
```

```
2020-04-28T16:19:57.840055Z [local] [executor-1] INFO a.d.c.service.CustomerService - Customer created about 10s ago!
```
### The Scheduler
The scheduler provides various APIs for scheduling asynchronous jobs to run on a service periodically.

#### The Job Interface
To configure a job, we must first implement the core.framework.scheduler.Job interface. Let's add a simple job to our project alongside the domain, web, and service packages as app.demo.customer.job.SimpleJob:


```
package app.demo.customer.job;
import core.framework.scheduler.Job;
import core.framework.scheduler.JobContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class SimpleJob implements Job {
    private final Logger logger = LoggerFactory.getLogger(SimpleJob.class);
    @Override
    public void execute(JobContext context) throws Exception {
        logger.info("Running the simple job!");
    }
}
```
Classes that implement core.framework.scheduler.Job must override the execute method. For now, we will simply log a message to the console.

#### Scheduling the Job
Back in our CustomerModule, we can now schedule the job using the various APIs provided by the scheduler. Let's schedule this job to run every minute, as well as once a day at noon:


```
package app;
import app.demo.api.CustomerWebService;
import app.demo.customer.domain.Customer;
import app.demo.customer.job.SimpleJob;
import app.demo.customer.service.CustomerService;
import app.demo.customer.web.CustomerWebServiceImpl;
import core.framework.module.Module;
import core.framework.scheduler.Job;
import java.time.Duration;
import java.time.LocalTime;
public class CustomerModule extends Module {
    @Override
    protected void initialize() {
        db().repository(Customer.class);
        bind(CustomerService.class);
        api().service(CustomerWebService.class, bind(CustomerWebServiceImpl.class));
        Job simpleJob = bind(SimpleJob.class);
        schedule().fixedRate("simple-fixed", simpleJob, Duration.ofMinutes(1));
        schedule().dailyAt("simple-daily", simpleJob, LocalTime.NOON);
    }
}
```
That's it, our fixed-rate and daily jobs are scheduled! For more scheduling options, see core.framework.module.SchedulerConfig.

#### Testing our Scheduled Jobs
To test if our scheduled jobs are running, start the app via the gradle menu by launching the task demo-service -> Tasks -> application -> run. If you wait around a few minues, you should see the logs from our fixed-rate task running as scheduled:


```
2020-05-28T20:28:56.541990Z [Charlies-MBP] [scheduler-1] INFO c.f.i.scheduler.Scheduler - execute scheduled job, job=simple-fixed, rate=PT1M, scheduled=2020-05-28T16:28:56.539630-04:00[America/New_York], next=2020-05-28T16:29:56.539630-04:00[America/New_York]
2020-05-28T20:28:56.545649Z [Charlies-MBP] [scheduler-job-1] INFO a.d.c.job.SimpleJob - Running the simple job!
2020-05-28T20:29:04.398671Z [Charlies-MBP] [background-task-1] INFO c.f.i.resource.Pool - refresh resource pool, pool=db
2020-05-28T20:29:56.545280Z [Charlies-MBP] [scheduler-1] INFO c.f.i.scheduler.Scheduler - execute scheduled job, job=simple-fixed, rate=PT1M, scheduled=2020-05-28T16:29:56.539630-04:00[America/New_York], next=2020-05-28T16:30:56.539630-04:00[America/New_York]
2020-05-28T20:29:56.545783Z [Charlies-MBP] [scheduler-job-2] INFO a.d.c.job.SimpleJob - Running the simple job!
2020-05-28T20:30:56.543935Z [Charlies-MBP] [scheduler-1] INFO c.f.i.scheduler.Scheduler - execute scheduled job, job=simple-fixed, rate=PT1M, scheduled=2020-05-28T16:30:56.539630-04:00[America/New_York], next=2020-05-28T16:31:56.539630-04:00[America/New_York]
2020-05-28T20:30:56.544640Z [Charlies-MBP] [scheduler-job-3] INFO a.d.c.job.SimpleJob - Running the simple job!
```
If you wait until noon (not recommended unless it's currently 11:59AM), you should see our daily task too!

### Core-ng Kafka
#### Defining the Message
Core-ng provides support for Kafka out of the box. In order to allow for easy consumption of Kafka messages between services, the message domain objects should be defined as part of the service interface. Let's define a very simple Kafka message under the demo-service-interface as app.demo.api.customer.kafka.CustomerCreatedMessage:


```
package app.demo.api.customer.kafka;
import core.framework.api.json.Property;
import core.framework.api.validate.NotBlank;
import core.framework.api.validate.NotNull;
public class CustomerCreatedMessage {
    @NotNull
    @NotBlank
    @Property(name = "email")
    public String email;
}
```
#### Publishing the Message
In order to have the ability to publish the message, we can use the Kafka config on our CustomerModule in the demo-service, which has the demo-service-interface as a dependency in gradle:


```
package app;
import app.demo.api.CustomerWebService;
import app.demo.api.customer.kafka.CustomerCreatedMessage;
import app.demo.customer.domain.Customer;
import app.demo.customer.job.SimpleJob;
import app.demo.customer.service.CustomerService;
import app.demo.customer.web.CustomerWebServiceImpl;
import core.framework.module.Module;
import core.framework.scheduler.Job;
import java.time.Duration;
import java.time.LocalTime;
public class CustomerModule extends Module {
    @Override
    protected void initialize() {
        kafka().publish("customer-created", CustomerCreatedMessage.class);
        db().repository(Customer.class);
        bind(CustomerService.class);
        api().service(CustomerWebService.class, bind(CustomerWebServiceImpl.class));
        Job simpleJob = bind(SimpleJob.class);
        schedule().fixedRate("simple-fixed", simpleJob, Duration.ofMinutes(1));
        schedule().dailyAt("simple-daily", simpleJob, LocalTime.NOON);
    }
}
```
Notice we specify the Kafka topic name when we set up the publisher config. Before we publish a message, let's also add the local docker Kafka uri to our sys.properties file so the Kafka config knows where to reach the service:


```
sys.jdbc.password=root
sys.jdbc.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=utf-8
sys.jdbc.user=root
sys.kafka.uri=localhost:9092
```
We can now inject a MessagePublisher from core.framework.kafka.MessagePublisher into one of our services which will allow us to publish a message to the 'customer-created' topic. Let's publish a message when a customer is created in our CustomerService:


```
package app.demo.customer.service;
import app.demo.api.customer.CreateCustomerRequest;
import app.demo.api.customer.CustomerView;
import app.demo.api.customer.kafka.CustomerCreatedMessage;
import app.demo.customer.domain.Customer;
import core.framework.async.Executor;
import core.framework.db.Repository;
import core.framework.inject.Inject;
import core.framework.kafka.MessagePublisher;
import core.framework.util.Strings;
import core.framework.web.exception.ConflictException;
import core.framework.web.exception.NotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Optional;
public class CustomerService {
    private final Logger logger = LoggerFactory.getLogger(CustomerService.class);
    @Inject
    Repository<Customer> customerRepository;
    @Inject
    Executor executor;
    @Inject
    MessagePublisher<CustomerCreatedMessage> customerCreatedMessagePublisher;
    public CustomerView create(CreateCustomerRequest request) {
        Optional<Customer> existingCustomer = customerRepository.selectOne("email = ?", request.email);
        if (existingCustomer.isPresent()) {
            throw new ConflictException(Strings.format("customer already exists, email={}", request.email));
        }
        Customer customer = new Customer();
        customer.email = request.email;
        customer.firstName = request.firstName;
        customer.lastName = request.lastName;
        customer.updatedTime = LocalDateTime.now();
        customer.id = customerRepository.insert(customer).orElseThrow();
        executor.submit("normal-task", () -> {
            logger.info("Customer created!");
        });
        executor.submit("delayed-task", () -> {
            logger.info("Customer created about 10s ago!");
        }, Duration.ofSeconds(10));
        CustomerCreatedMessage createdMessage = new CustomerCreatedMessage();
        createdMessage.email = customer.email;
        customerCreatedMessagePublisher.publish(createdMessage);
        return view(customer);
    }
    public CustomerView get(Long id) {
        Customer customer = customerRepository.get(id).orElseThrow(() -> new NotFoundException(Strings.format("customer not found, id={}", id)));
        return view(customer);
    }
    private CustomerView view(Customer customer) {
        CustomerView result = new CustomerView();
        result.id = customer.id;
        result.email = customer.email;
        result.firstName = customer.firstName;
        result.lastName = customer.lastName;
        result.updatedTime = customer.updatedTime;
        return result;
    }
}
```
#### Subscribing to the Message
In addition to setting up the message publishing, we also use the Kafka config to subscribe to messages. Before we can subscribe to a message, however, we must define a message handler. In our demo-service let's create a message handler as app.demo.customer.kafka.CustomerMessageHandler:


```
package app.demo.customer.kafka;
import app.demo.api.customer.kafka.CustomerCreatedMessage;
import core.framework.kafka.MessageHandler;
import core.framework.util.Strings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class CustomerCreatedMessageHandler implements MessageHandler<CustomerCreatedMessage> {
    private final Logger logger = LoggerFactory.getLogger(CustomerCreatedMessageHandler.class);
    @Override
    public void handle(String key, CustomerCreatedMessage value) {
        logger.info(Strings.format("Customer created, email={}", value.email));
    }
}
```
A proper handler must implement the core.framework.kafka.MessageHandler class for a given message and override that class's handle method.

For now, our handler will just log the email of the created customer published on the CustomerCreatedMessage. With our handler setup, we can now subscribe to the message in our CustomerModule:


```
package app;
import app.demo.api.CustomerWebService;
import app.demo.api.customer.kafka.CustomerCreatedMessage;
import app.demo.customer.domain.Customer;
import app.demo.customer.job.SimpleJob;
import app.demo.customer.kafka.CustomerCreatedMessageHandler;
import app.demo.customer.service.CustomerService;
import app.demo.customer.web.CustomerWebServiceImpl;
import core.framework.module.Module;
import core.framework.scheduler.Job;
import java.time.Duration;
import java.time.LocalTime;
public class CustomerModule extends Module {
    @Override
    protected void initialize() {
        kafka().publish("customer-created", CustomerCreatedMessage.class);
        kafka().subscribe("customer-created", CustomerCreatedMessage.class, bind(CustomerCreatedMessageHandler.class));
        db().repository(Customer.class);
        bind(CustomerService.class);
        api().service(CustomerWebService.class, bind(CustomerWebServiceImpl.class));
        Job simpleJob = bind(SimpleJob.class);
        schedule().fixedRate("simple-fixed", simpleJob, Duration.ofMinutes(1));
        schedule().dailyAt("simple-daily", simpleJob, LocalTime.NOON);
    }
}
```
To complete our subscription we have done the following:
- specified the topic that the message is published to (by convention this is the dash-separated version of the message class name, without "message". So, the CustomerCreatedMessage is published to the 'customer-created' topic)
- specified the message class CustomerCreatedMessage
- bound and specified our message handler class CustomerCreatedMessageHandler

By default, Core-ng will setup a subscription to the 'customer-created' topic with a consumer group id equal to the app name. Optionally, a consumer group Id can be manually specified via the kafka().groupId("some-group-id") api. See core.framework.module.KafkaConfig.java for more detail.

Another detail worth noting is that in this particular case, because we have only defined one service in our project, the demo-service is both the publisher and a consumer of our CustomerCreatedMessage. Often, we will want a different service to subscribe to our message, which in this case is as simple as including the demo-service-interface as a dependency for that service and setting up a message handler as described above.

#### Testing our Kafka Setup.
Start the app via the gradle menu by launching the task demo-service -> Tasks -> application -> run. Now let's create a customer:


```
> curl --header "Content-Type: application/json" \
  --request POST \
  --data '{"first_name": "Charlie", "last_name": "Fox", "email": "charlie@remarkablefoods.com"}' \
  <http://localhost:8080/customer> | json_pp
```
You should then see our subscribed handler log the the email of the created customer:


```
2020-08-05T16:28:57.847513Z [Charlies-MacBook-Pro.local] [kafka-listener-0] INFO a.d.c.kafka.CustomerCreatedMessageHandler - Customer created, email=charlie@remarkablefoods.com
2020-08-05T16:28:57.849877Z [Charlies-MacBook-Pro.local] [kafka-listener] INFO c.f.i.kafka.MessageListenerThread - process kafka records, count=1, size=39, elapsed=4235882
```
We've successfully published and subscribed to a Kafka message/topic with Core-ng!
## 1.6 - Running Core-NG projects locally

### Introduction

This guide will show how to run core-ng projects locally so that you can debug, put breakpoints and step through your code to test your changes by hitting the endpoint locally and stepping through the code to ensure changes made function as intended. This example has been made using foodtruck-chef-app.

One of the biggest pain points to running the foodtruck-chef-app locally is the authentication. In the foodtruck-chef-app there is a a login interceptor that calls the SessionsV2 service-class that calls the identity-service to return a LoginUserV2 object. That object is injected into the context to provide details on the currently logged in user and is used to allow the passage of protected REST API endpoints.

To solve the issue of having to mock identity-service we will be using a hack-y trick where we return our own LoginUserV2 object so we can have access to API endpoints.

### Pre-requisites

- Docker Compose
- In your /etc/hosts file add the following:


```
127.0.0.1	test.foodtruck-qa.com
127.0.0.1	test.foodtruck-uat.com
127.0.0.1 kafka-0.kafka.dev.svc.cluster.local kafka-v2-0.kafka-v2.uat.svc.cluster.local kafka-v2-0.kafka-v2.staging.svc.cluster.local kafka-0.kafka.prod.svc.cluster.local
127.0.0.1 kafka elasticsearch
```
#### Running Locally

- Load the foodtruck-chef-app project
- In the terminal type make up
  a. This should spin up the whole infrastructure required by foodtruck-chef-app
  b. Use docker ps to verify all containers are running and re-run the make if some containers fail to run.
- In the chef-site/src/main/java/app/chefsite/web/interceptor/LoginInterceptor.java replace the intercept method with the following method:



```
@Override
public Response intercept(Invocation invocation) throws Exception {
    if (invocation.annotation(LoginRequired.class) != null) {
        LoginUserV2.UserPermission permissions = new LoginUserV2.UserPermission();
        permissions.isSuperAdmin = true;
        LoginUserV2.UserPermission.Role role = new LoginUserV2.UserPermission.Role();
        role.roleId = "1";
        role.appCode = "RANDOM_APP_CODE";
        role.roleName = "role-user";
        role.appName = "role-app";
        List<LoginUserV2.UserPermission.Role> roleList = new ArrayList<>();
        roleList.add(role);
        permissions.roles = roleList;
        LoginUserV2 loginUser = new LoginUserV2();
        loginUser.id = "1";
        loginUser.userPermission = permissions;
        loginUser.email = "YOUR@EMAIL";
        loginUser.fullName = "YOUR_NAME";
        invocation.context().put(Contexts.CURRENT_USER, loginUser);
    }
    return invocation.proceed();
}
```
This
- In the chef-site/src/main/java/app/chefsite/web/interceptor/AuthenticationInterceptor.java replace the intercept method with the following method:


```
@Override
public Response intercept(Invocation invocation) throws Exception {
    return invocation.proceed();
}
```
- Then in the Main.java you can run the main method in debug mode, add breakpoints and hit the API

Donâ€™t forget to port forward to any services your API endpoint calls.

After doing this, check the helmfile.yaml and locate the targetPort. The target port will be needed for the API call. In the case of the foodtruck-chef-app the targetPort is 8443.

Now you can make HTTP calls to the server. The following URL is an example I hit using Postman:

`https://test.foodtruck-qa.com:8443/ajax/user/current`

This the returns the payload for that endpoint and from there you should be good to go.

## 1.7 - API Rate Limiting

### how to use
background: use the `@LimitRate`


```
@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface LimitRate {
    String value();
}
```


```
// first step: config limit rate in module
http().limitRate().add("group-name", 5, 20, TimeUnit.MINUTES);
 ```


```
// second: API declaration
public class ServiceImpl implements WebService {
    @LimitRate("group-name")
    @Override
    public Response methodName(Request request) {
        return null;
    }
}
```

### what it happens
when it config


```
public final class HTTPConfig extends Config {
    ...
    public LimitRateConfig limitRate() {
        return context.config(LimitRateConfig.class, null);
    }
    ...
}
```


```
public final class LimitRateConfig extends Config {
    private boolean rateControlGroupAdded;
    private RateControl rateControl;
    @Override
    protected void initialize(ModuleContext context, String name) {
        rateControl = context.httpServer.handler.rateControl; // new object when create HttpHandler
        // save at max 5K group/ip combination per pod, about 800K memory, to adapt with more ips/cc attack, better defense with cloud infra based solution together
        maxEntries(5000);
        context.httpServerConfig.interceptors.add(new LimitRateInterceptor(rateControl)); // use Interceptor to do the rate limit
    }
    @Override
    protected void validate() {
        if (!rateControlGroupAdded) {
            throw new Error("limitRate is configured but no group added, please remove unnecessary config");
        }
    }
    // how many group/ip combinations to keep, 5000 is about 800K, 10K is about 1.8M
    public void maxEntries(int entries) {
        rateControl.maxEntries(entries);
    }
    // maintain maxPermits at most, fill permits by fillRate per interval
    // e.g. add("group", 10, 5, Duration.ofSeconds(1)) keeps 10 permits at most, fills 5 permits every second
    // e.g. add("group", 20, 10, Duration.ofMinutes(5)) keeps 20 permits at most, fills 10 permits every 5 minutes
    public void add(String group, int maxPermits, int fillRate, Duration interval) {
        rateControl.config(group, maxPermits, fillRate, interval);
        rateControlGroupAdded = true;
    }
}
```

### how it works


```
public class LimitRateInterceptor implements Interceptor {
    private final RateControl rateControl;
    public LimitRateInterceptor(RateControl rateControl) {
        this.rateControl = rateControl;
    }
    @Override
    public Response intercept(Invocation invocation) throws Exception {
        LimitRate limitRate = invocation.annotation(LimitRate.class);
        if (limitRate != null) {
            String group = limitRate.value();
            String clientIP = invocation.context().request().clientIP();
            rateControl.validateRate(group, clientIP);
        }
        return invocation.proceed();
    }
}
```


```
public class RateControl {
    private final Logger logger = LoggerFactory.getLogger(RateControl.class);
    public Map<String, RateConfig> config;
    private Map<String, Rate> rates;
    public void maxEntries(int entries) {
        synchronized (this) {
            rates = new LRUMap<>(entries); // memory consideration
        }
    }
    public void config(String group, int maxPermits, int fillRate, Duration interval) {
        if (config == null) config = Maps.newHashMap();
        double fillRatePerNano = ratePerNano(fillRate, interval);
        RateConfig previous = config.put(group, new RateConfig(maxPermits, fillRatePerNano));
        if (previous != null) throw new Error("found duplicate group, group=" + group);
    }
    public void validateRate(String group, String clientIP) {
        logger.debug("acquire, group={}, clientIP={}", group, clientIP);
        boolean acquired = acquire(group, clientIP);
        if (!acquired) {
            throw new TooManyRequestsException("rate exceeded");
        }
    }
    double ratePerNano(int rate, Duration interval) {
        return rate / (double) interval.toNanos();
    }
    boolean acquire(String group, String clientIP) {
        RateConfig config = this.config.get(group);
        if (config == null) {
            logger.warn("can not find group, group={}", group);
            return true;    // skip if group is not defined
        }
        String key = group + "/" + clientIP;
        Rate rate;
        synchronized (this) {
            rate = rates.computeIfAbsent(key, k -> new Rate(config.maxPermits));
        }
        long currentTime = System.nanoTime();
        return rate.acquire(currentTime, config.maxPermits, config.fillRatePerNano);
    }
    record RateConfig(int maxPermits, double fillRatePerNano) {
    }
    static final class Rate {
        volatile double currentPermits;
        volatile long lastUpdateTime;
        Rate(int currentPermits) {
            this.currentPermits = currentPermits;
            this.lastUpdateTime = System.nanoTime();
        }
        // under multi-thread condition, the order of acquires are not determined, currentTime can be earlier than lastUpdateTime (e.g. lastUpdateTime was updated by a later acquire first)
        boolean acquire(long currentTime, int maxPermits, double fillRatePerNano) {
            synchronized (this) {
                long timeElapsed = Math.max(0, currentTime - lastUpdateTime);
                currentPermits = Math.min(maxPermits, currentPermits + fillRatePerNano * timeElapsed);
                lastUpdateTime = lastUpdateTime + timeElapsed;
                if (currentPermits >= 1) {
                    currentPermits -= 1;
                    return true;
                } else {
                    return false;
                }
            }
        }
    }
}
```
### Summary
- The rate limiting implemented by the token bucket algorithm.And only applies to single instance, if there are multiple instances, other methods are needed.
- Due to the use of LRUMap, the least recently accessed Rate object in rates will be deleted. The rate limit may be inaccurate if removed and re-added frequently, but the probability is low. The default maximum length is now 5000, which is generally sufficient.
- The key of rate object is group/clientIP,that is, maximum number of requests for a service api within 1s = number of clients x maximum number of requests configured.

# CoreNG Example
## build a new module named example
Assume that we have a project named example-project, and the work tree like this:


```
.
â”œâ”€â”€ backend
â”‚   â”œâ”€â”€ example-service
â”‚   â”‚   â”œâ”€â”€ conf
â”‚   â”‚   â”œâ”€â”€ docker
â”‚   â”‚   â””â”€â”€ src
â”‚   â”‚       â”œâ”€â”€ main
â”‚   â”‚       â”‚   â”œâ”€â”€ java
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ app
â”‚   â”‚       â”‚   â”‚       â””â”€â”€ example
â”‚   â”‚       â”‚   â”‚           â””â”€â”€ ExampleApp.java
â”‚   â”‚       â”‚   â”œâ”€â”€ Main.java
```
Step1. Create ExampleModule.java in the directory  ./backend/example-service/src/main/java/app/example, the code is as below:


```
package app.example;
import core.framework.module.Module;
/**
 * @author AI full stack engineer - Cter
 */
public class ExampleModule extends Module {
    @Override
    protected void initialize() {
    }
}
```
You can load other module, bind service, bind api service or bind kafka handler in the override method  initialize.

Step2. Load this module in the ExampleApp.java method initialize


```
public class ExampleApp extends App {
...
    @Override
    protected void initialize() {
    ...
        load(new ExampleModule());
    ...
    }
...
}
```
Done
## setup a scheduler job in individual scheduler-service

For example, we want to inactive HDR every day at 06:00.

First, we need to trigger a message in scheduler-service at every day 06:00, to do these:

Step1. define a Kafka message like this:


```
package app.kms.kafka;
/**
 * @author Jun
 */
public class AutoInactiveTestingHDRMessage {
}
```
Step2. add schedule job in the scheduler module like this:


```
package app.scheduler;
import app.scheduler.kitchenmanagement.AutoInactiveTestingHDRJob;
import core.framework.async.Executor;
import core.framework.module.Module;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZonedDateTime;
/**
 * @author eden
 */
public class KitchenManagementSchedulerModule extends Module {
    @Override
    protected void initialize() { 
    ...
        kafka().publish(HDRTopic.AUTO_INACTIVE_TESTING_HDR_EVENT, AutoInactiveTestingHDRMessage.class);
        schedule().dailyAt("auto-inactive-testing-hdr-job", bind(AutoInactiveTestingHDRJob.class), LocalTime.of(6, 0));
    ...
```	
Second, add jobs like this:


```
package app.scheduler.kitchenmanagement;
import app.kms.kafka.AutoInactiveTestingHDRMessage;
import core.framework.inject.Inject;
import core.framework.kafka.MessagePublisher;
import core.framework.scheduler.Job;
import core.framework.scheduler.JobContext;
/**
* @author Jun
  */
  public class AutoInactiveTestingHDRJob implements Job {
  @Inject
  MessagePublisher<AutoInactiveTestingHDRMessage> publisher;
  @Override
  public void execute(JobContext context) throws Exception {
  publisher.publish(new AutoInactiveTestingHDRMessage());
  }
  }
```
Last, consume this message and handle it like this:


```
package app.kms.hdr.kafka;
import app.kms.hdr.service.BOHDRServiceV3;
import app.kms.kafka.AutoInactiveTestingHDRMessage;
import core.framework.inject.Inject;
import core.framework.internal.log.LogManager;
import core.framework.kafka.MessageHandler;
import core.framework.log.ActionLogContext;
import javax.annotation.Nullable;
/**
* @author Jun
  */
  public class AutoInactiveTestingHDRMessageHandler implements MessageHandler<AutoInactiveTestingHDRMessage> {
  @Inject
  BOHDRServiceV3 bohdrServiceV3;
  @Override
  public void handle(@Nullable String key, AutoInactiveTestingHDRMessage value) {
  ActionLogContext.put("operator", "System");
  bohdrServiceV3.autoInactiveTestingHDR("System", LogManager.APP_NAME);
  }
  }
```
## register an API client and call an endpoint in it
For example, Assume we want to call TagWebService#getTag in ExampleApp, we need to:

First, add package dependency in gradle if required.

Second, register in the moduleâ€™s intialize method like this:


```
...
api().client(TagWebService.class, requiredProperty("app.recipeV2.serviceURL"));
...
```
Last, inject in service and call like this:


```
...
//inject web client
public class CookingGroupValidationService {
@Inject
TagWebService tagWebService;
public Map<String, String> getCooking(String tagId) {
...
// call endpoint
var tag = tagWebService.getTag(tagId);
// other logic
...
}
```
Done
## define a mysql domain

In the CoreNG framework, use annotation `@Column` to define a column, use annotation `@PrimaryKey` to define the primary column, and use annotation `@Table` to define a MySQL table.

Here is an example:


```
package app.kos.domain;
import core.framework.api.validate.NotNull;
import core.framework.db.Column;
import core.framework.db.PrimaryKey;
import core.framework.db.Table;
import java.time.ZonedDateTime;
/**
* @author harry
  */
  @Table(name = "cash_payments")
  public class CashPayment {
  @PrimaryKey
  @Column(name = "id")
  public String id;
  @NotNull
  @Column(name = "order_id")
  public String orderId;
  @NotNull
  @Column(name = "cash_amount")
  public Double cashAmount;
  @NotNull
  @Column(name = "created_by")
  public String createdBy;
  @NotNull
  @Column(name = "created_time")
  public ZonedDateTime createdTime;
  @NotNull
  @Column(name = "updated_by")
  public String updatedBy;
  @NotNull
  @Column(name = "updated_time")
  public ZonedDateTime updatedTime;
  }
```
The corresponding flyway SQL script is:


```
CREATE TABLE IF NOT EXISTS `cash_payments`
(
`id`                        VARCHAR(50)     NOT NULL,
`order_id`                  VARCHAR(50)     NOT NULL,
`cash_amount`               DECIMAL(10, 2)  NOT NULL,
`created_time`              TIMESTAMP(6)    NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
`created_by`                VARCHAR(50)     NOT NULL,
`updated_time`              TIMESTAMP(6)    NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
`updated_by`                VARCHAR(50)     NOT NULL,
PRIMARY KEY (`id`),
INDEX `cash_payment_order_id` (`order_id` ASC)
) ENGINE = InnoDB;
```

## define a mongo domain
In CoreNG, using annotation `@Field` to define a field of a collection, using annotation `@Id` to define the primary field, using annotation `@Collection` with name value to define the collection name, using annotation `MongoEnumValue` to define an enum value.

Example:


```
package app.kms.exceptionoperationhour.collection;
import core.framework.api.validate.NotNull;
import core.framework.mongo.Collection;
import core.framework.mongo.Field;
import core.framework.mongo.Id;
import core.framework.mongo.MongoEnumValue;
import java.time.ZonedDateTime;
/**
* @author stephen
  */
  @Collection(name = "exception_operation_hours")
  public class ExceptionOperationHour {
  @Id
  @Field(name = "_id")
  public String id;
  @NotNull
  @Field(name = "resource_id")
  public String resourceId;
  @NotNull
  @Field(name = "resource_type")
  public ResourceType resourceType;
  @NotNull
  @Field(name = "operate_type")
  public OperateType operateType;
  @NotNull
  @Field(name = "duration_type")
  public DurationType durationType;
  @NotNull
  @Field(name = "start_time")
  public ZonedDateTime startTime;
  @NotNull
  @Field(name = "end_time")
  public ZonedDateTime endTime;
  @NotNull
  @Field(name = "expiration_time")
  public ZonedDateTime expirationTime;
  @Field(name = "reason")
  public String reason;
  @Field(name = "operator")
  public String operator;
  @NotNull
  @Field(name = "created_by")
  public String createdBy;
  @NotNull
  @Field(name = "created_time")
  public ZonedDateTime createdTime;
  @NotNull
  @Field(name = "updated_by")
  public String updatedBy;
  @NotNull
  @Field(name = "updated_time")
  public ZonedDateTime updatedTime;
  public enum DurationType {
  @MongoEnumValue("TIME_RANGE")
  TIME_RANGE,
  @MongoEnumValue("REST_OF_THE_DATE")
  REST_OF_THE_DATE
  }
  public enum ResourceType {
  @MongoEnumValue("HDR")
  HDR,
  @MongoEnumValue("HDR_RESTAURANT")
  HDR_RESTAURANT
  }
  public enum OperateType {
  @MongoEnumValue("CLOSE")
  CLOSE,
  @MongoEnumValue("PAUSE")
  PAUSE,
  @MongoEnumValue("POSTPONE")
  POSTPONE
  }
  }
```
## publish kafka message
To publish a Kafka message for example when the hdr configuration is updated in CoreNG you need to:

First, define a message in the API package like:

```

package app.kms.kafka;
import core.framework.api.json.Property;
import core.framework.api.validate.NotNull;
/**
* @author stephen
  */
  public class HDRConfigurationUpdatedMessage {
  @NotNull
  @Property(name = "event_type")
  public EventType eventType = EventType.UPDATED;
  public enum EventType {
  @Property(name = "UPDATED")
  UPDATED
  }
  }
```
Second, register in the moduleâ€™s initialize method like this:


```
...
kafka().publish(HDRTopic.HDR_CONFIGURATION_UPDATED_EVENT, HDRConfigurationUpdatedMessage.class);
...
```      
Last, publish when the HDR configuration updated message like this:


```
...
private void updateHDRConfiguration(String hdrId, SuperPodBuilder builder, BOApplyLayoutRequest request) {
...
hdrConfigurationCollection.replace(hdrConfiguration);
hdrConfigurationUpdatedMessagePublisher.publish(hdrId, new HDRConfigurationUpdatedMessage());
}
...
``` 
Done.
## subscribe and handle a Kafka message
To subscribe to a Kafka message for example HDRConfigurationUpdatedMessage we need:

First, add package dependency in build.gradle.kts if needed

Second, subscribe it in the moduleâ€™s initialize method like this:


```
...
kafka().subscribe(HDRTopic.HDR_CONFIGURATION_UPDATED_EVENT, HDRConfigurationUpdatedMessage.class, bind(HDRConfigurationUpdatedMessageHandler.class));
...
```
Last, implement handler like this:


```
package app.kos.kafka;
import app.kms.kafka.HDRConfigurationUpdatedMessage;
import app.kos.cache.HDRConfigurationCacheService;
import core.framework.inject.Inject;
import core.framework.kafka.MessageHandler;
import core.framework.log.ActionLogContext;
import javax.annotation.Nullable;
/**
* @author Yanni
  */
  public class HDRConfigurationUpdatedMessageHandler implements MessageHandler<HDRConfigurationUpdatedMessage> {
  @Inject
  HDRConfigurationCacheService hdrConfigurationCacheService;
  @Override
  public void handle(@Nullable String hdrId, HDRConfigurationUpdatedMessage value) throws Exception {
  ActionLogContext.put("hdr_id", hdrId);
  if (value.eventType == HDRConfigurationUpdatedMessage.EventType.UPDATED) {
  hdrConfigurationCacheService.evict(hdrId);
  }
  }
  }
```
## add and load self-defined properties

Assuming we have properties that need to be defined and it does not belong to any other existing properties , we need to add a file named example.properties in /path/to/servier/conf/qa/example.properties , content like this:


```
example.property.key=value
```
we also need to add this file in /path/to/servier/conf/uat and /path/to/servier/conf/prod and /path/to/service/src/main/resources , core-ng will check the property existed in the all env property file, and we must keep the properties in the files are all order the same.

Then, load and use it like this:


```
...
// load property file
loadProperties("app.properties");
...
...
// use property using key
requiredProperty("example.property.key")
...
```
Done
## define post release controller
To set up a post-release controller we need to add a file named ExampleController.java in `/path/to/service/src/main/java/app/controller/ExampleController.java`, with content like this:


```
package app.kms.datasync.controller;
import core.framework.web.Controller;
import core.framework.web.Request;
import core.framework.web.Response;
/**
* @author Stephen
  */
  public class ExampleController implements Controller {
  @Override
  public Response execute(Request request) throws Exception {
  //do post release logic
  return Response.text("OK");
  }
  }
```